\subsection{Eingabe (\emph{input})}
In der Eingabe-Bibliothek werden die Taster, das Potentiometer und der Drehgeber (auch Encoder) ausgelesen und dem Rest des Programms in Form von Flaggen zur Auswertung zur Verfügung gestellt. Es werden die Interrupts an Port 2 empfangen und ausgelesen, die jeweilige Flagge gesetzt und der Low-Power-Modus beendet, damit die Flaggen sofort ausgelesen und darauf reagiert werden kann.

\subsubsection{\source{void input\_init()}}
Die Funktion initialisiert den Port 2 so, dass die Interrupts ausgelöst werden und damit auf die Eingaben reagiert werden kann. Außerdem wird der Analog-Digital-Umsetzer (engl. ADC) passend konfiguriert, um das Potentiometer auszulesen. Dafür wird das Capture/Compare-Register 0 (CCR0) des Timer A verwendet, das den ADC hunderte Male pro Sekunde zum Auslesen des gerade anliegenden Potentiometerwertes anregt. CCR0 wird dementsprechend konfiguriert und das Auslesen wird in \source{\_\_interrupt void CCR0\_ISR()} angeregt.

\subsubsection{Flaggen}
Es gibt für jeden Taster eine Flagge (\source{bool button\_SW4} bis \source{bool button\_SW1} entsprechend der Tasternummer), eine Flagge \source{potentiometer\_new} für einen neuen Wert des Potentiometers und zwei Flaggen \source{bool encoder\_l} und \source{bool encoder\_r} für die beiden Drehrichtungen des Encoders.

\subsubsection{\source{\_\_interrupt void P2\_ISR()}}
Die ISR für Port 2, die aufgerufen wird, sobald ein Taster oder der Encoder betätigt werden. Dort wird überprüft, ob der Encoder und wenn ja, in welche Richtung er gedreht wurde. Da die Taster prellen, dürfen die Tasterdrücke nicht sofort ausgewertet werden, da ansonsten bei jedem Tastendruck fälschlicherweise viele Tastendrücke erkannt werden würden. Deswegen wird über die Wartefunktion \source{void debounce\_delay()} eine passende Wartezeit vor der Auswertung realisiert. Je nachdem, welcher Taster oder welche Encoder-Richtung erkannt wurde, wird die entsprechende Flagge gesetzt und der Prozessor aus dem Schlafmodus aufgeweckt, um in der \source{main()}-Funktion darauf zu reagieren.

\subsubsection{\source{\_\_interrupt void ADC10\_ISR()}}
Diese Interrupt Service Routine wird immer dann aufgerufen, sobald ein neuer Wert vom ADC gemessen wurde. Dies bedeutet aber nicht notwendigerweise eine Änderung des Wertes also eine Benutzereingabe. Es muss also ein Vergleich mit dem vorherigen Wert stattfinden, deswegen gibt es zwei Variablen: \source{pot\_value} und \source{pot\_value\_old}. Der ADC gibt 10bit-Werte aus, für das Projekt wollen wir aber nur zwischen 16 Werten unterscheiden (die Schritte der Sequenz). Dies entspricht einer 4bit-Zahl, also wird der ADC-Wert um 6 Werte nach rechts bit-verschoben und dann erst in \source{pot\_value} gespeichert. Falls dieser Wert nicht mit \source{pot\_value\_old} übereinstimmt wird die Flagge \source{potentiometer\_new} gesetzt und der Schlafmodus verlassen, um darauf zu reagieren.
